package service

import (
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/grigri/pv/internal/errors"
	"github.com/grigri/pv/internal/infra"
	"github.com/grigri/pv/internal/model"
	"github.com/grigri/pv/internal/utils"
	"github.com/grigri/pv/internal/validator"
)

// promptServiceImpl implements the PromptService interface
type promptServiceImpl struct {
	store     infra.Store
	validator validator.YAMLValidator
}

// NewPromptService creates a new prompt service with the given dependencies
func NewPromptService(
	store infra.Store,
	validator validator.YAMLValidator,
) PromptService {
	return &promptServiceImpl{
		store:     store,
		validator: validator,
	}
}

// AddFromFile reads a YAML file, validates it, and adds it to the store
func (p *promptServiceImpl) AddFromFile(filePath string) (*model.Prompt, error) {
	// Validate file path
	if strings.TrimSpace(filePath) == "" {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"file path cannot be empty",
			errors.ErrFileNotFound,
		)
	}

	// Convert to absolute path for consistency
	absPath, err := filepath.Abs(filePath)
	if err != nil {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"invalid file path",
			err,
		)
	}

	// Check if file exists
	if _, err := os.Stat(absPath); os.IsNotExist(err) {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"file does not exist: "+absPath,
			errors.ErrFileNotFound,
		)
	}

	// Read file content
	content, err := ioutil.ReadFile(absPath)
	if err != nil {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"failed to read file: "+absPath,
			err,
		)
	}

	// Validate file content using the YAML validator
	promptFileContent, err := p.validator.ValidatePromptFile(content)
	if err != nil {
		return nil, err // Error already wrapped by validator
	}

	// Validate required fields
	if err := p.validator.ValidateRequired(promptFileContent); err != nil {
		return nil, err // Error already wrapped by validator
	}

	// Convert PromptFileContent to Prompt model
	prompt := &model.Prompt{
		ID:          "", // ID will be generated by the store
		Name:        promptFileContent.Metadata.Name,
		Author:      promptFileContent.Metadata.Author,
		Description: promptFileContent.Metadata.Description,
		Tags:        promptFileContent.Metadata.Tags,
		Version:     promptFileContent.Metadata.Version,
		Content:     string(content),
		GistURL:     "", // GistURL will be set by the store after creating the gist
	}

	// Add prompt to store (this will handle GitHub Gist creation and index updates)
	if err := p.store.Add(*prompt); err != nil {
		return nil, errors.NewAppError(
			errors.ErrStorage,
			"failed to add prompt to store",
			err,
		)
	}

	return prompt, nil
}

// DeleteByKeyword deletes prompts that match the given keyword
func (p *promptServiceImpl) DeleteByKeyword(keyword string) error {
	log.Printf("Starting delete by keyword: %s", keyword)
	
	// Validate input
	if strings.TrimSpace(keyword) == "" {
		return errors.NewAppError(
			errors.ErrValidation,
			"keyword cannot be empty",
			errors.ErrPromptNotFound.Err,
		)
	}

	// Use Store.Get() to find matching prompts
	matchingPrompts, err := p.store.Get(keyword)
	if err != nil {
		log.Printf("Failed to search prompts by keyword '%s': %v", keyword, err)
		return errors.NewAppError(
			errors.ErrStorage,
			"failed to search for prompts",
			err,
		)
	}

	// Check if any prompts were found
	if len(matchingPrompts) == 0 {
		log.Printf("No prompts found matching keyword: %s", keyword)
		return errors.ErrNoPromptsToDelete
	}

	// For multiple matches, we need to handle them appropriately
	// In a real implementation, this would be handled by the TUI layer
	// For now, we'll delete all matching prompts
	log.Printf("Found %d prompts matching keyword '%s'", len(matchingPrompts), keyword)

	// Execute deletion for each matching prompt
	for _, prompt := range matchingPrompts {
		log.Printf("Deleting prompt: %s (ID: %s)", prompt.Name, prompt.ID)
		err := p.store.Delete(prompt.ID)
		if err != nil {
			log.Printf("Failed to delete prompt %s: %v", prompt.Name, err)
			return errors.NewAppError(
				errors.ErrStorage,
				"failed to delete prompt: "+prompt.Name,
				err,
			)
		}
	}

	log.Printf("Successfully deleted %d prompts matching keyword '%s'", len(matchingPrompts), keyword)
	return nil
}

// DeleteByURL deletes a prompt identified by its GitHub Gist URL
func (p *promptServiceImpl) DeleteByURL(gistURL string) error {
	log.Printf("Starting delete by URL: %s", gistURL)
	
	// Validate URL format
	gistID, err := utils.ExtractGistID(gistURL)
	if err != nil {
		log.Printf("Invalid Gist URL format: %s", gistURL)
		return err
	}

	log.Printf("Extracted Gist ID: %s", gistID)

	// Use Store.Get() to verify the prompt exists by searching with the gist ID
	matchingPrompts, err := p.store.Get(gistID)
	if err != nil {
		log.Printf("Failed to search for prompt with Gist ID '%s': %v", gistID, err)
		return errors.NewAppError(
			errors.ErrStorage,
			"failed to search for prompt",
			err,
		)
	}

	// Check if the prompt was found
	if len(matchingPrompts) == 0 {
		log.Printf("No prompt found with Gist ID: %s", gistID)
		return errors.ErrPromptNotFound
	}

	// Delete the prompt using the gist ID
	log.Printf("Deleting prompt with Gist ID: %s", gistID)
	err = p.store.Delete(gistID)
	if err != nil {
		log.Printf("Failed to delete prompt with Gist ID '%s': %v", gistID, err)
		return errors.NewAppError(
			errors.ErrStorage,
			"failed to delete prompt",
			err,
		)
	}

	log.Printf("Successfully deleted prompt with Gist ID: %s", gistID)
	return nil
}

// ListPrompts retrieves all prompts available in the vault
func (p *promptServiceImpl) ListPrompts() ([]model.Prompt, error) {
	log.Printf("Listing all prompts")
	
	prompts, err := p.store.List()
	if err != nil {
		// Handle specific store errors with user-friendly messages
		if err == infra.ErrNoIndex {
			log.Printf("No prompt index found - first time user")
			return nil, errors.NewAppError(
				errors.ErrValidation,
				"没有找到提示索引 - 这似乎是您第一次使用 pv",
				err,
			)
		}
		if err == infra.ErrEmptyIndex {
			log.Printf("No prompts found in collection")
			return nil, errors.ErrNoPromptsToDelete
		}
		
		log.Printf("Failed to list prompts: %v", err)
		return nil, errors.NewAppError(
			errors.ErrStorage,
			"failed to list prompts",
			err,
		)
	}

	log.Printf("Found %d prompts available", len(prompts))
	return prompts, nil
}

// FilterPrompts retrieves prompts that match the given keyword
func (p *promptServiceImpl) FilterPrompts(keyword string) ([]model.Prompt, error) {
	log.Printf("Filtering prompts with keyword: %s", keyword)
	
	// Validate input
	if strings.TrimSpace(keyword) == "" {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"keyword cannot be empty",
			errors.ErrPromptNotFound.Err,
		)
	}

	// Use Store.Get() to filter prompts
	matchingPrompts, err := p.store.Get(keyword)
	if err != nil {
		// Handle specific store errors
		if err == infra.ErrNoIndex {
			log.Printf("No prompt index found - first time user")
			return nil, errors.NewAppError(
				errors.ErrValidation,
				"没有找到提示索引 - 这似乎是您第一次使用 pv",
				err,
			)
		}
		if err == infra.ErrEmptyIndex {
			log.Printf("No prompts found in collection")
			return nil, errors.ErrNoPromptsToDelete
		}
		
		log.Printf("Failed to filter prompts with keyword '%s': %v", keyword, err)
		return nil, errors.NewAppError(
			errors.ErrStorage,
			"failed to filter prompts",
			err,
		)
	}

	log.Printf("Found %d prompts matching keyword '%s'", len(matchingPrompts), keyword)
	
	// Return empty slice if no matches (not an error condition for filtering)
	return matchingPrompts, nil
}

// GetPromptByURL retrieves a specific prompt by its GitHub Gist URL
func (p *promptServiceImpl) GetPromptByURL(gistURL string) (*model.Prompt, error) {
	log.Printf("Getting prompt by URL: %s", gistURL)
	
	// Validate URL format and extract Gist ID
	gistID, err := utils.ExtractGistID(gistURL)
	if err != nil {
		log.Printf("Invalid Gist URL format: %s", gistURL)
		return nil, err
	}

	log.Printf("Extracted Gist ID: %s", gistID)

	// Use Store.Get() to find the prompt by gist ID
	matchingPrompts, err := p.store.Get(gistID)
	if err != nil {
		// Handle specific store errors
		if err == infra.ErrNoIndex {
			log.Printf("No prompt index found - first time user")
			return nil, errors.NewAppError(
				errors.ErrValidation,
				"没有找到提示索引 - 这似乎是您第一次使用 pv",
				err,
			)
		}
		if err == infra.ErrEmptyIndex {
			log.Printf("No prompts found in collection")
			return nil, errors.NewAppError(
				errors.ErrValidation,
				"没有找到任何提示词",
				err,
			)
		}
		
		log.Printf("Failed to search for prompt with Gist ID '%s': %v", gistID, err)
		return nil, errors.NewAppError(
			errors.ErrStorage,
			"failed to search for prompt",
			err,
		)
	}

	// Check if the prompt was found
	if len(matchingPrompts) == 0 {
		log.Printf("No prompt found with Gist ID: %s", gistID)
		return nil, errors.ErrPromptNotFound
	}

	// Return the first matching prompt (should be only one for a specific URL)
	prompt := matchingPrompts[0]
	log.Printf("Found prompt: %s (ID: %s)", prompt.Name, prompt.ID)
	return &prompt, nil
}

// GetPromptContent retrieves the actual content of a prompt from GitHub Gist
func (p *promptServiceImpl) GetPromptContent(prompt *model.Prompt) (string, error) {
	// Validate input first before logging
	if prompt == nil {
		log.Printf("GetPromptContent called with nil prompt")
		return "", errors.NewAppError(
			errors.ErrValidation,
			"prompt cannot be nil",
			errors.ErrPromptNotFound.Err,
		)
	}
	
	log.Printf("Getting content for prompt: %s (ID: %s)", prompt.Name, prompt.ID)
	
	if strings.TrimSpace(prompt.ID) == "" {
		return "", errors.NewAppError(
			errors.ErrValidation,
			"prompt ID cannot be empty",
			errors.ErrPromptNotFound.Err,
		)
	}

	// Use the store to get the content
	content, err := p.store.GetContent(prompt.ID)
	if err != nil {
		log.Printf("Failed to get content for prompt %s: %v", prompt.ID, err)
		return "", errors.NewAppError(
			errors.ErrStorage,
			"failed to retrieve prompt content",
			err,
		)
	}

	log.Printf("Successfully retrieved content for prompt: %s", prompt.Name)
	return content, nil
}

// extractGistID extracts and validates the Gist ID from a GitHub Gist URL
