package service

import (
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/grigri/pv/internal/errors"
	"github.com/grigri/pv/internal/infra"
	"github.com/grigri/pv/internal/model"
	"github.com/grigri/pv/internal/validator"
)

// promptServiceImpl implements the PromptService interface
type promptServiceImpl struct {
	store     infra.Store
	validator validator.YAMLValidator
}

// NewPromptService creates a new prompt service with the given dependencies
func NewPromptService(
	store infra.Store,
	validator validator.YAMLValidator,
) PromptService {
	return &promptServiceImpl{
		store:     store,
		validator: validator,
	}
}

// AddFromFile reads a YAML file, validates it, and adds it to the store
func (p *promptServiceImpl) AddFromFile(filePath string) (*model.Prompt, error) {
	// Validate file path
	if strings.TrimSpace(filePath) == "" {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"file path cannot be empty",
			errors.ErrFileNotFound,
		)
	}

	// Convert to absolute path for consistency
	absPath, err := filepath.Abs(filePath)
	if err != nil {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"invalid file path",
			err,
		)
	}

	// Check if file exists
	if _, err := os.Stat(absPath); os.IsNotExist(err) {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"file does not exist: "+absPath,
			errors.ErrFileNotFound,
		)
	}

	// Read file content
	content, err := ioutil.ReadFile(absPath)
	if err != nil {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"failed to read file: "+absPath,
			err,
		)
	}

	// Validate file content using the YAML validator
	promptFileContent, err := p.validator.ValidatePromptFile(content)
	if err != nil {
		return nil, err // Error already wrapped by validator
	}

	// Validate required fields
	if err := p.validator.ValidateRequired(promptFileContent); err != nil {
		return nil, err // Error already wrapped by validator
	}

	// Convert PromptFileContent to Prompt model
	prompt := &model.Prompt{
		ID:          "", // ID will be generated by the store
		Name:        promptFileContent.Metadata.Name,
		Author:      promptFileContent.Metadata.Author,
		Description: promptFileContent.Metadata.Description,
		Tags:        promptFileContent.Metadata.Tags,
		Version:     promptFileContent.Metadata.Version,
		Content:     string(content),
		GistURL:     "", // GistURL will be set by the store after creating the gist
	}

	// Add prompt to store (this will handle GitHub Gist creation and index updates)
	if err := p.store.Add(*prompt); err != nil {
		return nil, errors.NewAppError(
			errors.ErrStorage,
			"failed to add prompt to store",
			err,
		)
	}

	return prompt, nil
}
