package service

import (
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/grigri/pv/internal/errors"
	"github.com/grigri/pv/internal/infra"
	"github.com/grigri/pv/internal/model"
	"github.com/grigri/pv/internal/utils"
	"github.com/grigri/pv/internal/validator"
)

// promptServiceImpl implements the PromptService interface
type promptServiceImpl struct {
	store     infra.Store
	validator validator.YAMLValidator
}

// NewPromptService creates a new prompt service with the given dependencies
func NewPromptService(
	store infra.Store,
	validator validator.YAMLValidator,
) PromptService {
	return &promptServiceImpl{
		store:     store,
		validator: validator,
	}
}

// AddFromFile reads a YAML file, validates it, and adds it to the store
func (p *promptServiceImpl) AddFromFile(filePath string) (*model.Prompt, error) {
	// Validate file path
	if strings.TrimSpace(filePath) == "" {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"file path cannot be empty",
			errors.ErrFileNotFound,
		)
	}

	// Convert to absolute path for consistency
	absPath, err := filepath.Abs(filePath)
	if err != nil {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"invalid file path",
			err,
		)
	}

	// Check if file exists
	if _, err := os.Stat(absPath); os.IsNotExist(err) {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"file does not exist: "+absPath,
			errors.ErrFileNotFound,
		)
	}

	// Read file content
	content, err := ioutil.ReadFile(absPath)
	if err != nil {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"failed to read file: "+absPath,
			err,
		)
	}

	// Validate file content using the YAML validator
	promptFileContent, err := p.validator.ValidatePromptFile(content)
	if err != nil {
		return nil, err // Error already wrapped by validator
	}

	// Validate required fields
	if err := p.validator.ValidateRequired(promptFileContent); err != nil {
		return nil, err // Error already wrapped by validator
	}

	// Convert PromptFileContent to Prompt model
	prompt := &model.Prompt{
		ID:          "", // ID will be generated by the store
		Name:        promptFileContent.Metadata.Name,
		Author:      promptFileContent.Metadata.Author,
		Description: promptFileContent.Metadata.Description,
		Tags:        promptFileContent.Metadata.Tags,
		Version:     promptFileContent.Metadata.Version,
		Content:     string(content),
		GistURL:     "", // GistURL will be set by the store after creating the gist
	}

	// Add prompt to store (this will handle GitHub Gist creation and index updates)
	if err := p.store.Add(*prompt); err != nil {
		return nil, errors.NewAppError(
			errors.ErrStorage,
			"failed to add prompt to store",
			err,
		)
	}

	return prompt, nil
}

// DeleteByKeyword deletes prompts that match the given keyword
func (p *promptServiceImpl) DeleteByKeyword(keyword string) error {
	log.Printf("Starting delete by keyword: %s", keyword)
	
	// Validate input
	if strings.TrimSpace(keyword) == "" {
		return errors.NewAppError(
			errors.ErrValidation,
			"keyword cannot be empty",
			errors.ErrPromptNotFound.Err,
		)
	}

	// Use Store.Get() to find matching prompts
	matchingPrompts, err := p.store.Get(keyword)
	if err != nil {
		log.Printf("Failed to search prompts by keyword '%s': %v", keyword, err)
		return errors.NewAppError(
			errors.ErrStorage,
			"failed to search for prompts",
			err,
		)
	}

	// Check if any prompts were found
	if len(matchingPrompts) == 0 {
		log.Printf("No prompts found matching keyword: %s", keyword)
		return errors.ErrNoPromptsToDelete
	}

	// For multiple matches, we need to handle them appropriately
	// In a real implementation, this would be handled by the TUI layer
	// For now, we'll delete all matching prompts
	log.Printf("Found %d prompts matching keyword '%s'", len(matchingPrompts), keyword)

	// Execute deletion for each matching prompt
	for _, prompt := range matchingPrompts {
		log.Printf("Deleting prompt: %s (ID: %s)", prompt.Name, prompt.ID)
		err := p.store.Delete(prompt.ID)
		if err != nil {
			log.Printf("Failed to delete prompt %s: %v", prompt.Name, err)
			return errors.NewAppError(
				errors.ErrStorage,
				"failed to delete prompt: "+prompt.Name,
				err,
			)
		}
	}

	log.Printf("Successfully deleted %d prompts matching keyword '%s'", len(matchingPrompts), keyword)
	return nil
}

// DeleteByURL deletes a prompt identified by its GitHub Gist URL
func (p *promptServiceImpl) DeleteByURL(gistURL string) error {
	log.Printf("Starting delete by URL: %s", gistURL)
	
	// Validate URL format
	gistID, err := utils.ExtractGistID(gistURL)
	if err != nil {
		log.Printf("Invalid Gist URL format: %s", gistURL)
		return err
	}

	log.Printf("Extracted Gist ID: %s", gistID)

	// Use Store.Get() to verify the prompt exists by searching with the gist ID
	matchingPrompts, err := p.store.Get(gistID)
	if err != nil {
		log.Printf("Failed to search for prompt with Gist ID '%s': %v", gistID, err)
		return errors.NewAppError(
			errors.ErrStorage,
			"failed to search for prompt",
			err,
		)
	}

	// Check if the prompt was found
	if len(matchingPrompts) == 0 {
		log.Printf("No prompt found with Gist ID: %s", gistID)
		return errors.ErrPromptNotFound
	}

	// Delete the prompt using the gist ID
	log.Printf("Deleting prompt with Gist ID: %s", gistID)
	err = p.store.Delete(gistID)
	if err != nil {
		log.Printf("Failed to delete prompt with Gist ID '%s': %v", gistID, err)
		return errors.NewAppError(
			errors.ErrStorage,
			"failed to delete prompt",
			err,
		)
	}

	log.Printf("Successfully deleted prompt with Gist ID: %s", gistID)
	return nil
}

// ListPrompts retrieves all prompts available in the vault
func (p *promptServiceImpl) ListPrompts() ([]model.Prompt, error) {
	log.Printf("Listing all prompts")
	
	prompts, err := p.store.List()
	if err != nil {
		// Handle specific store errors with user-friendly messages
		if err == infra.ErrNoIndex {
			log.Printf("No prompt index found - first time user")
			return nil, errors.NewAppError(
				errors.ErrValidation,
				"没有找到提示索引 - 这似乎是您第一次使用 pv",
				err,
			)
		}
		if err == infra.ErrEmptyIndex {
			log.Printf("No prompts found in collection")
			return nil, errors.ErrNoPromptsToDelete
		}
		
		log.Printf("Failed to list prompts: %v", err)
		return nil, errors.NewAppError(
			errors.ErrStorage,
			"failed to list prompts",
			err,
		)
	}

	log.Printf("Found %d prompts available", len(prompts))
	return prompts, nil
}

// FilterPrompts retrieves prompts that match the given keyword
func (p *promptServiceImpl) FilterPrompts(keyword string) ([]model.Prompt, error) {
	log.Printf("Filtering prompts with keyword: %s", keyword)
	
	// Validate input
	if strings.TrimSpace(keyword) == "" {
		return nil, errors.NewAppError(
			errors.ErrValidation,
			"keyword cannot be empty",
			errors.ErrPromptNotFound.Err,
		)
	}

	// Use Store.Get() to filter prompts
	matchingPrompts, err := p.store.Get(keyword)
	if err != nil {
		// Handle specific store errors
		if err == infra.ErrNoIndex {
			log.Printf("No prompt index found - first time user")
			return nil, errors.NewAppError(
				errors.ErrValidation,
				"没有找到提示索引 - 这似乎是您第一次使用 pv",
				err,
			)
		}
		if err == infra.ErrEmptyIndex {
			log.Printf("No prompts found in collection")
			return nil, errors.ErrNoPromptsToDelete
		}
		
		log.Printf("Failed to filter prompts with keyword '%s': %v", keyword, err)
		return nil, errors.NewAppError(
			errors.ErrStorage,
			"failed to filter prompts",
			err,
		)
	}

	log.Printf("Found %d prompts matching keyword '%s'", len(matchingPrompts), keyword)
	
	// Return empty slice if no matches (not an error condition for filtering)
	return matchingPrompts, nil
}

// GetPromptByURL retrieves a specific prompt by its GitHub Gist URL
func (p *promptServiceImpl) GetPromptByURL(gistURL string) (*model.Prompt, error) {
	log.Printf("Getting prompt by URL: %s", gistURL)
	
	// Validate URL format and extract Gist ID
	gistID, err := utils.ExtractGistID(gistURL)
	if err != nil {
		log.Printf("Invalid Gist URL format: %s", gistURL)
		return nil, err
	}

	log.Printf("Extracted Gist ID: %s", gistID)

	// Use Store.Get() to find the prompt by gist ID
	matchingPrompts, err := p.store.Get(gistID)
	if err != nil {
		// Handle specific store errors
		if err == infra.ErrNoIndex {
			log.Printf("No prompt index found - first time user")
			return nil, errors.NewAppError(
				errors.ErrValidation,
				"没有找到提示索引 - 这似乎是您第一次使用 pv",
				err,
			)
		}
		if err == infra.ErrEmptyIndex {
			log.Printf("No prompts found in collection")
			return nil, errors.NewAppError(
				errors.ErrValidation,
				"没有找到任何提示词",
				err,
			)
		}
		
		log.Printf("Failed to search for prompt with Gist ID '%s': %v", gistID, err)
		return nil, errors.NewAppError(
			errors.ErrStorage,
			"failed to search for prompt",
			err,
		)
	}

	// Check if the prompt was found
	if len(matchingPrompts) == 0 {
		log.Printf("No prompt found with Gist ID: %s", gistID)
		return nil, errors.ErrPromptNotFound
	}

	// Return the first matching prompt (should be only one for a specific URL)
	prompt := matchingPrompts[0]
	log.Printf("Found prompt: %s (ID: %s)", prompt.Name, prompt.ID)
	return &prompt, nil
}

// GetPromptContent retrieves the actual content of a prompt from GitHub Gist
func (p *promptServiceImpl) GetPromptContent(prompt *model.Prompt) (string, error) {
	// Validate input first before logging
	if prompt == nil {
		log.Printf("GetPromptContent called with nil prompt")
		return "", errors.NewAppError(
			errors.ErrValidation,
			"prompt cannot be nil",
			errors.ErrPromptNotFound.Err,
		)
	}
	
	log.Printf("Getting content for prompt: %s (ID: %s)", prompt.Name, prompt.ID)
	
	if strings.TrimSpace(prompt.ID) == "" {
		return "", errors.NewAppError(
			errors.ErrValidation,
			"prompt ID cannot be empty",
			errors.ErrPromptNotFound.Err,
		)
	}

	// Use the store to get the content
	content, err := p.store.GetContent(prompt.ID)
	if err != nil {
		log.Printf("Failed to get content for prompt %s: %v", prompt.ID, err)
		return "", errors.NewAppError(
			errors.ErrStorage,
			"failed to retrieve prompt content",
			err,
		)
	}

	log.Printf("Successfully retrieved content for prompt: %s", prompt.Name)
	return content, nil
}

// SharePrompt 实现分享私有 prompt 的完整流程
func (p *promptServiceImpl) SharePrompt(prompt *model.Prompt) (*model.Prompt, error) {
	// 0. 获取完整的 prompt 内容（因为传入的 prompt 可能只包含元数据）
	completePrompt := prompt
	if strings.TrimSpace(prompt.Content) == "" {
		// 如果 Content 为空，说明只有元数据，需要获取完整内容
		content, err := p.store.GetContent(prompt.ID)
		if err != nil {
			return nil, errors.NewShareError("获取完整内容", prompt.GistURL, err)
		}
		
		// 解析 YAML 内容获取完整的 prompt 信息
		parsedPrompt, err := p.parseYAMLContent(content, prompt.GistURL)
		if err != nil {
			return nil, errors.NewShareError("解析 prompt 内容", prompt.GistURL, err)
		}
		
		// 合并元数据和内容
		completePrompt = &model.Prompt{
			ID:          prompt.ID,
			Name:        prompt.Name,        // 优先使用原有的元数据
			Author:      prompt.Author,      // 优先使用原有的元数据  
			GistURL:     prompt.GistURL,
			Description: parsedPrompt.Description,
			Tags:        parsedPrompt.Tags,
			Version:     parsedPrompt.Version,
			Content:     content,            // 完整的原始内容
			Parent:      prompt.Parent,
		}
	}
	
	// 1. 验证访问权限
	gistInfo, err := p.store.GetGistInfo(completePrompt.GistURL)
	if err != nil {
		return nil, errors.NewShareError("验证访问权限", completePrompt.GistURL, err)
	}
	
	if gistInfo.IsPublic {
		return nil, errors.ErrGistAlreadyPublic
	}
	
	if !gistInfo.HasAccess {
		return nil, errors.ErrGistAccessDenied
	}
	
	// 2. 检查现有导出
	exports, err := p.store.GetExports()
	if err != nil {
		return nil, err
	}
	
	var existingExport *model.IndexedPrompt
	for _, export := range exports {
		if export.Parent != nil && *export.Parent == completePrompt.GistURL {
			exportCopy := export // 避免循环变量地址问题
			existingExport = &exportCopy
			break
		}
	}
	
	// 3. 创建或更新公开 Gist
	var gistURL string
	var sharedPrompt *model.Prompt
	
	if existingExport != nil {
		// 更新现有公开 gist 的内容
		err = p.store.UpdateGist(existingExport.GistURL, *completePrompt)
		if err != nil {
			return nil, err
		}
		gistURL = existingExport.GistURL
		
		// 更新导出记录的时间戳
		existingExport.LastUpdated = time.Now()
		err = p.store.UpdateExport(*existingExport)
		if err != nil {
			return nil, err
		}
		
		// 转换为完整的 Prompt 对象返回
		sharedPrompt = &model.Prompt{
			ID:          p.extractGistID(gistURL),
			Name:        existingExport.Name,
			Author:      existingExport.Author,
			GistURL:     gistURL,
			Description: completePrompt.Description,
			Tags:        completePrompt.Tags,
			Version:     completePrompt.Version,
			Content:     completePrompt.Content,
			Parent:      existingExport.Parent,
		}
	} else {
		// 创建新的公开 gist
		gistURL, err = p.store.CreatePublicGist(*completePrompt)
		if err != nil {
			return nil, err
		}
		
		// 创建新的导出记录
		exportRecord := model.IndexedPrompt{
			GistURL:     gistURL,
			FilePath:    "", // exports 不需要本地文件路径
			Author:      completePrompt.Author,
			Name:        completePrompt.Name,
			LastUpdated: time.Now(),
			Parent:      &completePrompt.GistURL,
		}
		
		err = p.store.AddExport(exportRecord)
		if err != nil {
			return nil, err
		}
		
		// 返回完整的 Prompt 对象
		sharedPrompt = &model.Prompt{
			ID:          p.extractGistID(gistURL),
			Name:        completePrompt.Name,
			Author:      completePrompt.Author,
			GistURL:     gistURL,
			Description: completePrompt.Description,
			Tags:        completePrompt.Tags,
			Version:     completePrompt.Version,
			Content:     completePrompt.Content,
			Parent:      &completePrompt.GistURL,
		}
	}
	
	return sharedPrompt, nil
}

// AddFromURL 从公开 gist URL 导入 prompt
func (p *promptServiceImpl) AddFromURL(gistURL string) (*model.Prompt, error) {
	// 首先检查该 gist URL 是否已经存在
	existingPromptByURL, err := p.store.FindExistingPromptByURL(gistURL)
	if err != nil {
		return nil, errors.NewAddFromURLError("检查 gist URL 重复", gistURL, err)
	}
	
	if existingPromptByURL != nil {
		return nil, &errors.ErrPromptAlreadyExists
	}
	
	// 验证 gist 是公开的
	gistInfo, err := p.store.GetGistInfo(gistURL)
	if err != nil {
		return nil, errors.NewAddFromURLError("验证 gist 信息", gistURL, err)
	}
	
	if !gistInfo.IsPublic {
		return nil, &errors.ErrGistNotPublicFromURL
	}
	
	// 获取 gist 内容
	gistID := p.extractGistID(gistURL)
	content, err := p.store.GetContent(gistID)
	if err != nil {
		return nil, errors.NewAddFromURLError("获取 gist 内容", gistURL, err)
	}
	
	// 解析 YAML 内容为 Prompt
	prompt, err := p.parseYAMLContent(content, gistURL)
	if err != nil {
		return nil, &errors.ErrInvalidPromptFormatFromURL
	}
	
	// 添加到本地索引
	err = p.store.Add(*prompt)
	if err != nil {
		return nil, errors.NewAddFromURLError("添加到本地索引", gistURL, err)
	}
	
	return prompt, nil
}

// ValidateGistAccess 验证用户对 gist 的访问权限
func (p *promptServiceImpl) ValidateGistAccess(gistURL string) (*GistInfo, error) {
	infraGistInfo, err := p.store.GetGistInfo(gistURL)
	if err != nil {
		return nil, err
	}
	
	// 转换 infra.GistInfo 到 service.GistInfo
	return &GistInfo{
		ID:          infraGistInfo.ID,
		URL:         infraGistInfo.URL,
		IsPublic:    infraGistInfo.IsPublic,
		HasAccess:   infraGistInfo.HasAccess,
		Description: infraGistInfo.Description,
		Owner:       infraGistInfo.Owner,
	}, nil
}

// ListPrivatePrompts 列出所有私有 prompts
func (p *promptServiceImpl) ListPrivatePrompts() ([]model.Prompt, error) {
	allPrompts, err := p.ListPrompts()
	if err != nil {
		return nil, err
	}
	
	var privatePrompts []model.Prompt
	for _, prompt := range allPrompts {
		gistInfo, err := p.store.GetGistInfo(prompt.GistURL)
		if err != nil {
			continue // 跳过无法访问的 gist
		}
		if !gistInfo.IsPublic {
			privatePrompts = append(privatePrompts, prompt)
		}
	}
	
	return privatePrompts, nil
}

// FilterPrivatePrompts 根据关键字筛选私有 prompts
func (p *promptServiceImpl) FilterPrivatePrompts(keyword string) ([]model.Prompt, error) {
	allPrivatePrompts, err := p.ListPrivatePrompts()
	if err != nil {
		return nil, err
	}
	
	return p.filterPromptsByKeyword(allPrivatePrompts, keyword), nil
}

// Sync synchronizes the local cache with GitHub by downloading the raw index.json file
func (p *promptServiceImpl) Sync() error {
	log.Printf("Starting cache synchronization with GitHub")
	
	// Cast store to CachedStore to access SyncRawIndex
	cachedStore, ok := p.store.(*infra.CachedStore)
	if !ok {
		log.Printf("Store is not a CachedStore, skipping raw index sync")
		return nil // Not an error, just means we're not using cached storage
	}
	
	// Sync raw index.json content from GitHub to local cache
	if err := cachedStore.SyncRawIndex(); err != nil {
		log.Printf("Failed to sync raw index: %v", err)
		return errors.NewAppError(
			errors.ErrStorage,
			"failed to sync index with GitHub",
			err,
		)
	}
	
	log.Printf("Successfully synchronized cache with GitHub")
	return nil
}

// parseYAMLContent 解析 YAML 内容为 Prompt 对象
func (p *promptServiceImpl) parseYAMLContent(content string, gistURL string) (*model.Prompt, error) {
	// 使用现有的验证器解析 YAML 内容
	promptFileContent, err := p.validator.ValidatePromptFile([]byte(content))
	if err != nil {
		return nil, err
	}
	
	// 将解析后的内容转换为 Prompt 模型
	return &model.Prompt{
		ID:          p.extractGistID(gistURL),
		Name:        promptFileContent.Metadata.Name,
		Author:      promptFileContent.Metadata.Author,
		Description: promptFileContent.Metadata.Description,
		Tags:        promptFileContent.Metadata.Tags,
		Version:     promptFileContent.Metadata.Version,
		GistURL:     gistURL,
		Content:     content, // 保存原始内容
	}, nil
}

// extractGistID 从 URL 中提取 gist ID
func (p *promptServiceImpl) extractGistID(gistURL string) string {
	parts := strings.Split(gistURL, "/")
	return parts[len(parts)-1]
}

// filterPromptsByKeyword 根据关键字筛选 prompts（复用现有逻辑）
func (p *promptServiceImpl) filterPromptsByKeyword(prompts []model.Prompt, keyword string) []model.Prompt {
	if keyword == "" {
		return prompts
	}
	
	var filtered []model.Prompt
	lowerKeyword := strings.ToLower(keyword)
	
	for _, prompt := range prompts {
		if strings.Contains(strings.ToLower(prompt.Name), lowerKeyword) ||
			strings.Contains(strings.ToLower(prompt.Author), lowerKeyword) ||
			strings.Contains(strings.ToLower(prompt.Description), lowerKeyword) {
			filtered = append(filtered, prompt)
		}
	}
	
	return filtered
}

// extractGistID extracts and validates the Gist ID from a GitHub Gist URL
